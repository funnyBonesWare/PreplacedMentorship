
### <font color="#4bacc6">What is an “Event object” in the browser?</font>

- **Events represent things happening.**  
    Whenever the user clicks a button, presses a key, moves the mouse, submits a form, or when the browser itself fires something like “DOMContentLoaded,” JavaScript creates an object behind the scenes to describe exactly what happened. That object is called an **Event object**.
    
- **It carries details about the happening.**  
    When you click a button, you don’t just want to know “a click happened” — you also want details like:
    
    - **Which element** was clicked (the button, link, etc.).
        
    - **Where** on the page the mouse was when it was clicked (e.g., `clientX`, `clientY`).
        
    - **Which mouse button** was used (left, right, middle).
        
    - **Whether modifier keys** (Ctrl, Shift, Alt) were held down at the same time.  
        All of those details live on the Event object that the browser automatically hands you.
        
- **Every time you listen to an event, you get that Event object.**  
    Whenever you write code like:

``` js
const myButton = document.querySelector("#myButton");
myButton.addEventListener("click", function(event) {
  // ↳ the 'event' parameter here is the Event object
  console.log("User clicked!", event);
  })
```

The browser creates a fresh Event object and passes it as the first argument to your function. Inside that handler, you can inspect `event.type`, `event.target`, `event.preventDefault()`, and so on.

**There are specialized sub-types of Event objects.**

- If you listen for `"keydown"` or `"keypress"`, the browser gives you a **KeyboardEvent** (with extra properties like `event.key`, `event.code`, etc.).
    
- If you listen for `"mousemove"` or `"mousedown"`, you get a **MouseEvent** (with `event.clientX`/`clientY`, `event.button`, etc.).
    
- If you fire a custom event via JavaScript, you might get a **CustomEvent** (which can carry any additional data you attach).  
    Under the hood, all of these inherit from the base `Event` type, but they add specialized fields.

###  <font color="#4bacc6">Anatomy of a built-in Event object</font>

Let’s say you have a simple HTML button:

```HTML
<button id="saveBtn">Save</button>
```

and JavaScript like this:

```JS
const saveBtn = document.querySelector("#saveBtn");

saveBtn.addEventListener("click", function(event) {
  console.log("Event type:", event.type);           // "click"
  console.log("Event target:", event.target);       // <button id="saveBtn">Save</button>
  console.log("Mouse X/Y:", event.clientX, event.clientY);
  
  // Prevent the button’s default behavior (if it were e.g. a <button type="submit"> inside a form):
  event.preventDefault();                           
  
  // Stop the event from bubbling up the DOM tree:
  event.stopPropagation();                           
});
```


1. **`event.type`**
    
    - Tells you what kind of event it is (e.g., `"click"`, `"keydown"`, `"submit"`, etc.).
        
2. **`event.target`**
    
    - Points to the actual element that triggered the event (in our example, the `<button>`).
        
3. **Coordinates**
    
    - `event.clientX` and `event.clientY` give you the mouse’s position relative to the **window’s visible area** at the moment of the click.
        
4. **`preventDefault()`**
    
    - Many HTML elements have a “default action” (like a link navigating somewhere, a form submitting, a checkbox toggling). Calling `event.preventDefault()` stops that default from happening.
        
5. **`stopPropagation()`**
    
    - By default, events bubble — if you click a nested element, the same “click” event travels up from the innermost element to its parents. Calling `event.stopPropagation()` prevents it from continuing up the chain.
        
6. **More properties on specialized Event objects**
    
    - A **KeyboardEvent** has `event.key` (e.g., `"Enter"`, `"a"`, `"Shift"`), `event.code` (e.g., `"KeyA"`, `"Digit1"`), and booleans like `event.shiftKey`, `event.ctrlKey`.
        
    - A **MouseEvent** has `event.button` (0 for left, 1 for middle, 2 for right), `event.detail` (number of clicks), `event.movementX`/`movementY` (pixels moved since last mouse event), etc.
        

In short, an Event object is your “detailed report” of exactly what happened in the browser.

### <font color="#4bacc6">The built-in Event constructor function</font>

### Why would you ever call `new Event(...)` yourself?

Most of the time, you don’t manually say `new Event("click")` for native browser events—clicks happen because the user physically clicked. However, there are two main reasons you might use `new Event(...)` in your code:

1. **To dispatch a “synthetic” or “custom” event** that imitates a native one. For example, you might want to programmatically trigger a “resize” event or a custom “user-logged-in” event so that other parts of your code can react.
    
2. **To create a `CustomEvent` with extra data** (using `new CustomEvent("yourEvent", { detail: { ... } })`). This allows you to attach your own payload and have various parts of your app listen for it.

#### <font color="#f79646">Syntax of the built-in `Event` constructor</font>


``` js
// Basic Event:
const myEvent = new Event(typeString, eventInitObject);
```

- **`typeString`** (required): a string representing the event name (e.g., `"click"`, `"scroll"`, `"myCustomAction"`).
    
- **`eventInitObject`** (optional): an object with two possible boolean properties:
    
    - `bubbles` (default `false`): whether the event propagates (bubbles) up through the DOM.
        
    - `cancelable` (default `false`): whether `preventDefault()` can prevent the default action.

Example:

``` js
// Create a synthetic "click" event that bubbles and is cancelable:
const syntheticClick = new Event("click", {
  bubbles: true,
  cancelable: true
});

// Later, you can dispatch it on an element:
const button = document.querySelector("#myButton");
button.dispatchEvent(syntheticClick);
// This will run any "click" listeners on #myButton (and bubble up the chain).
```

#### <font color="#f79646">Creating a CustomEvent for user-defined data</font>

// Suppose you want to notify parts of your app that “userData” has changed:
const dataPayload = { userId: 123, name: "Sahil" };
const userDataChangedEvent = new CustomEvent("userDataChanged", {
  detail: dataPayload,   // put any extra fields you need inside `detail`
  bubbles: true,
  cancelable: false
});

// Somewhere else in your code, you listen:
document.addEventListener("userDataChanged", function(e) {
  console.log("Payload:", e.detail); // { userId: 123, name: "Sahil" }
});

// And when your data actually changes:
document.dispatchEvent(userDataChangedEvent);
