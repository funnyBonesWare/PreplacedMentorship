> [!summary] Definition
> Currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument.

Currying in JavaScript transforms a function with multiple arguments into a nested series of functions, each taking a single argument. Currying helps you avoid passing the same variable multiple times, and it helps you create a higher order function.

## <font color="#4bacc6">Why Is Currying in JavaScript Useful?</font>

1. Currying helps you avoid passing the same variable again and again.
2. It helps to create a higher order function.

Currying transforms a function with multiple arguments into a sequence/series of functions, each taking a single argument.

For example:

``` js
function sum(a, b, c) {
    return a + b + c;
}
sum(1,2,3); // 6
```

As you can see, this is a function with full arguments. Let’s create a curried version of the function and see how we would call the same function (and get the same result) in a series of calls

```js
function sum(a) {
    return (b) => {
        return (c) => {
            return a + b + c
        }
    }
}
console.log(sum(1)(2)(3)) // 6
```

We could even separate this `sum(1)(2)(3)` to understand it better:

```js
const sum1 = sum(1);
const sum2 = sum1(2);
const result = sum2(3);
console.log(result); // 6
```

## <font color="#4bacc6">How Does Currying in JavaScript Work?</font>

Let’s look at how currying works. We passed `1` to the `sum` function:

```js
let sum1 = sum(1);
```

It returns the function:

``` js
return (b) => {
    return (c) => {
        return a + b + c
    }
}
```

Now, `sum1` holds the above function definition, which takes an argument `b`.

We called the `sum1` function, passing in `2`:

```js
let sum2 = sum1(2);
```

The `sum1` will return the third function:

```js
return (c) => {
        return a + b + c
}
```

The returned function is now stored in the `sum2` variable.
`sum2` will be:

```js
sum2 = (c) => { 
	return a + b + c 
}
```

When `sum2` is called with `3` as the parameter `const result = sum2(3);`, it does the calculation with the previously passed in parameters: `a = 1`, `b = 2` and returns `6`.

```js
console.log(result); // 6
```

The last function only accepts the `c` variable, but it will perform the operation with other variables whose enclosing function scope has long since returned. It works nonetheless because of  **<font color="#c00000">Closure</font>**.

Closures make currying work by letting each nested function “remember” the arguments passed so far, even after its outer function has finished.
- **First Call (`sum(1)`)**
    
    - When you call `sum(1)`, JavaScript creates a new function that takes `b`. That inner function closes over (i.e., captures) the variable `a = 1`. Even after `sum` returns, this returned function still “knows” that `a` is 1.
        
- **Second Call (`sum(1)(2)`)**
    
    - You now call the returned function with `2`. This gives you yet another function that takes `c`. It closes over both `a = 1` and `b = 2`. Thanks to the closure, that innermost function retains access to both values from its outer scopes.
        
- **Final Call (`sum(1)(2)(3)`)**
    
    - Calling the innermost function with `3` triggers `a + b + c`. The closure makes sure `a` and `b` are still available, so it correctly computes `1 + 2 + 3 = 6`.

Without closures, each nested layer wouldn’t remember earlier arguments. Currying transforms a three-argument function into a chain of single-argument functions; closures ensure each step retains the previous values until the very last call. This pattern, rooted in classic functional programming, not only keeps your code modular and elegant but also opens the door to more advanced techniques—like partial application or building configurable helpers—pushing JavaScript forward in a traditional, time-tested way.
## <font color="#4bacc6">Basic vs. Advanced Currying Techniques</font>

Basically, there are two types of Currying in JavaScript. Let us have a look at them.
1. **Basic Currying**
2. **Advanced Currying**
In Basic currying, a single argument is taken by the function and returns a series of functions under which all the other parameters are contained.

In this currying, the function is incomplete until all the parameters are received by the function. Otherwise, the function will not give any **fruitful results**.

While in Advanced currying, there is a fixed number of parameters in the function. In it, the function is received as an outer function which is a **wrapper function**.

Let us see examples of both the currying in JavaScript for better understanding.
- **Basic currying**:
```js
const getCakeIngredients = (ingred_1) =>{ // function is declared here
    return (ingred_2) => {
        return (ingred_3) => {
            return ${ingred_1}, ${ingred_2}, ${ingred_3}; 
        } 
    } 
} 
getCakeIngredients('Eggs')('flour')('milk');
```

